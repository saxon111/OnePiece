{"code":"// 1.Promise是一个类，类中的构造函数需要传入一个excutor 默认就会执行\r\n// 2.executor中有两个参数 分别是resolve，reject\r\n// 3.默认创建一个proimise 状态就是pending  fulfilled  rejected  promise有三个状态\r\n// 4.调用成功和失败时 需要传递一个成功的原因和失败的原因\r\n// 5.如果已经成功了就不能失败了\r\n// 6.每一个promise实例都有一个then方法\r\n// 7.如果抛出异常按照失败来处理\r\n// promise的链式调用问题\r\n// 1.如果then方法中（成功或者失败） 返回的不是一个promise，会将这个值传递给外层下一次then的成功结果\r\n// 2.如果执行then方法中的方法出错了 抛出异常 我走到下一个then的失败\r\n// 3.如果返回的是一个promise 会用这个promise的结果作为下一次then的成功或者失败\r\n// 1.出错会失败  2.返回的promise会出错\r\n// then方法为什么可以链式调用 每次调用then都返回一个新的promise\r\n// catch 就是then的别名 没有成功只有失败 （找最近的优先处理，处理不了找下一层）\r\nvar STATUS;\r\n(function (STATUS) {\r\n    STATUS[\"pending\"] = \"PENDING\";\r\n    STATUS[\"fulfilled\"] = \"FULFILLED\";\r\n    STATUS[\"rejected\"] = \"REJECTED\";\r\n})(STATUS || (STATUS = {}));\r\n// 核心逻辑，解析x类型，决定promise2走成功还是失败\r\nfunction resolvePromise(promise2, x, resolve, reject) {\r\n    if (promise2 === x) {\r\n        return reject(new TypeError(\"Chaining cycle detected for promise!\"));\r\n    }\r\n    if (x !== null && (typeof x === \"object\" || typeof x === \"function\")) {\r\n        // 只有x是对象或者函数才可能是promise\r\n        var thenCalledOrThrow_1 = false;\r\n        try {\r\n            var then = x.then;\r\n            if (typeof then === \"function\") {\r\n                then.call(x, function (y) {\r\n                    if (thenCalledOrThrow_1)\r\n                        return;\r\n                    thenCalledOrThrow_1 = true;\r\n                    return resolvePromise(promise2, y, resolve, reject);\r\n                }, function (r) {\r\n                    if (thenCalledOrThrow_1)\r\n                        return;\r\n                    thenCalledOrThrow_1 = true;\r\n                    return reject(r);\r\n                });\r\n            }\r\n            else {\r\n                resolve(x);\r\n            }\r\n        }\r\n        catch (e) {\r\n            if (thenCalledOrThrow_1)\r\n                return;\r\n            thenCalledOrThrow_1 = true;\r\n            return reject(e);\r\n        }\r\n    }\r\n    else {\r\n        // 如果不是，肯定是普通值\r\n        resolve(x);\r\n    }\r\n}\r\nvar Promise = /** @class */ (function () {\r\n    function Promise(executor) {\r\n        var _this = this;\r\n        this.status = STATUS.pending;\r\n        this.value = undefined; // 成功原因\r\n        this.reason = undefined; // 失败原因\r\n        this.onResolvedCallback = [];\r\n        this.onRejectedCallback = [];\r\n        var resolve = function (value) {\r\n            if (value instanceof Promise) {\r\n                // 是promise 就继续递归解析\r\n                return value.then(resolve, reject);\r\n            }\r\n            if (_this.status === STATUS.pending) {\r\n                _this.status = STATUS.fulfilled;\r\n                _this.value = value;\r\n                _this.onResolvedCallback.forEach(function (fn) { return fn(); });\r\n            }\r\n        };\r\n        var reject = function (reason) {\r\n            if (_this.status === STATUS.pending) {\r\n                _this.status = STATUS.rejected;\r\n                _this.reason = reason;\r\n                _this.onRejectedCallback.forEach(function (fn) { return fn(); });\r\n            }\r\n        };\r\n        try {\r\n            executor(resolve, reject);\r\n        }\r\n        catch (e) {\r\n            reject(e);\r\n        }\r\n    }\r\n    Promise.prototype.then = function (onFulfilled, onRejected) {\r\n        var _this = this;\r\n        onFulfilled =\r\n            typeof onFulfilled === \"function\"\r\n                ? onFulfilled\r\n                : function (v) {\r\n                    return v;\r\n                };\r\n        onRejected =\r\n            typeof onRejected === \"function\"\r\n                ? onRejected\r\n                : function (r) {\r\n                    throw r;\r\n                };\r\n        var promise2 = new Promise(function (resolve, reject) {\r\n            if (_this.status === STATUS.fulfilled) {\r\n                setTimeout(function () {\r\n                    try {\r\n                        var x = onFulfilled(_this.value); // x可能是一个promise\r\n                        resolvePromise(promise2, x, resolve, reject);\r\n                    }\r\n                    catch (e) {\r\n                        reject(e);\r\n                    }\r\n                }, 0);\r\n            }\r\n            if (_this.status === STATUS.rejected) {\r\n                setTimeout(function () {\r\n                    try {\r\n                        var x = onRejected(_this.reason);\r\n                        resolvePromise(promise2, x, resolve, reject);\r\n                    }\r\n                    catch (e) {\r\n                        reject(e);\r\n                    }\r\n                }, 0);\r\n            }\r\n            if (_this.status === STATUS.pending) {\r\n                _this.onResolvedCallback.push(function () {\r\n                    setTimeout(function () {\r\n                        try {\r\n                            var x = onFulfilled(_this.value);\r\n                            resolvePromise(promise2, x, resolve, reject);\r\n                        }\r\n                        catch (e) {\r\n                            reject(e);\r\n                        }\r\n                    }, 0);\r\n                });\r\n                _this.onRejectedCallback.push(function () {\r\n                    setTimeout(function () {\r\n                        try {\r\n                            var x = onRejected(_this.reason);\r\n                            resolvePromise(promise2, x, resolve, reject);\r\n                        }\r\n                        catch (e) {\r\n                            reject(e);\r\n                        }\r\n                    }, 0);\r\n                });\r\n            }\r\n        });\r\n        return promise2;\r\n    };\r\n    return Promise;\r\n}());\r\nPromise.deferred = function () {\r\n    var dfd = {};\r\n    dfd.promise = new Promise(function (resolve, reject) {\r\n        dfd.resolve = resolve;\r\n        dfd.reject = reject;\r\n    });\r\n    return dfd;\r\n};\r\nexport default Promise;\r\n","references":[]}
